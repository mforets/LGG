{"kernelspec":{"display_name":"SageMath 6.10","language":"","name":"sagemath"},"language_info":{"codemirror_mode":{"name":"ipython","version":2},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython2","version":"2.7.10"}}
{"cell_type":"markdown","metadata":{},"source":"$\\newcommand{\\R}{\\mathbb{R}}$\n$\\newcommand{\\transp}{\\mathrm{T}}$\n$\\newcommand{\\jR}{\\mathcal{R}}$"}
{"cell_type":"markdown","metadata":{"collapsed":false},"source":"# B. The LGG Algorithm\n\n[SpaceEx](http://spaceex.imag.fr/) is a verification platform for hybrid systems. The basic functionality is to compute the set of reachable sets of a system. Currently, SpaceEx accepts piecewise-linear systems only. The standard way to deal with nonlinearities is to perform a local linearization of the system's dynamics, a method called *hybridization* in this area.  \n \nThe [LGG (Le Guernic-Girard)](http://ljk.imag.fr/membres/Antoine.Girard/Publications/cav2009.pdf) is an algorithm implemented in SpaceEx (along with more recent methods such as [STC](http://spaceex.imag.fr/sites/default/files/frehse_stc_lgg_comp.pdf)).  \n\nIn this worksheet we implement the linear part of the LGG algorithm of Le Guernic and Girard, described in [this paper](http://www-ljk.imag.fr/membres/Antoine.Girard/Publications/na-hs.pdf), and make a test in the following simple example. "}
{"cell_type":"markdown","metadata":{},"source":"## 1. Hybridization\n\nThe method known as hybridization consists in performing a local linearization around a set of positions in state-space. \n\nThis is an illustration of the hybridization technique, from [O. Maler, Computing Reachable Sets: An Introduction](http://www-verimag.imag.fr/~maler/Papers/reach-intro.pdf).\n![alt text](https://github.com/mforets/SMC-and-set-based-computations/blob/master/fig/hybridization.png?raw=true)"}
{"cell_type":"markdown","metadata":{"collapsed":true},"source":"## 2. A two-dimensional LTI example \n\nConsider the system\n$$\n\\begin{pmatrix}\n\\dot{x}_1 \\\\ \\dot{x}_2\n\\end{pmatrix} = \\begin{pmatrix} -1  & -4 \\\\ 4 & -1 \\end{pmatrix} \\begin{pmatrix}\nx_1 \\\\ x_2\n\\end{pmatrix} + \\begin{pmatrix} u_1 \\\\ u_2 \\end{pmatrix}.\n$$\nLet $\\mathcal{X}_0 = [0.9,1.1]\\times [-0.1,1.1]$ be the initial set. Suppose that $u_1(t),u_2(t) \\in B_\\infty(0,\\mu)$ for all $t\\geq 0$, with $\\mu=0.05$. What is the set of states reachable at time $T=2$? This two-dimensional example appears in [Gir05](http://www-ljk.imag.fr/membres/Antoine.Girard/Publications/hscc2005.pdf)."}
{"cell_type":"markdown","metadata":{},"source":"## 2.1. Numerical integration \n\nThe solution of the [LTI](https://en.wikipedia.org/wiki/LTI_system_theory) system $\\dot{x}=Ax + u$ is\n$$\nx(t) = e^{At}x_0 + \\int_0^t e^{A(t-s)}u(s) ds,\n$$\nwhere $x=(x_1,x_2)^\\transp$ and $u = (u_1, u_2)^\\transp$. Below we numericlly solve this integral for different values of the initial condition. Let us assume that $u_1(t) = \\mu\\cos t$ and $u_2(t) = \\mu \\sin t$, with $\\mu = 0.05$."}
{"cell_type":"markdown","metadata":{"collapsed":true,"trusted":true},"source":"*Exercise*. Compute the numerical integral, for different values of $x_0 \\in \\mathcal{X}_0 = [0.9,1.1]\\times [-0.1,1.1]$. \n*Hint:* Use sage function numerical_integral."}
{"cell_type":"markdown","metadata":{},"source":"## 3. Efficient algorithm for the computation of polyhedral approximations of the reachable set \n\nThis corresponds to Section 4 of [LGG09](http://www-ljk.imag.fr/membres/Antoine.Girard/Publications/na-hs.pdf). Consider the LTI system\n$$\n\\dot{x}(t) = Ax(t) + Bu(t),\n$$\nwith $u(t) \\in U \\subseteq \\R^{d'}$ a compact convex set; $A$ and $B$ are matrices of appropriate dimensions (we assume that the state-space is $n$-dimensional and over the real field). It is convenient to *homogeneize* the system by defining the set $V=BU \\subset \\R^n$, and consider the equivalent system\n$$\n\\dot{x}(t) = Ax(t) + v(t),\n$$\nwith $v(t) \\in V$. \n\n**Definition**. The set of states reachable at time $s>0$ from states in a given subset $X \\in \\R^n$ is\n$$\n\\jR_s(X) := \\{ x(s) : \\dot{x}=Ax+v,~v\\in V,~\\forall t \\in [0,s]\\text{ and } x(0) \\in X \\}.\n$$\nThe reachable set on the time interval $[s,s']$ is defined as \n$$\n\\jR_{[s,s']}(X) := \\bigcup\\limits_{t\\in[s,s']}\\jR_t(X).\n$$\n\nThis object is also often called *reach-pipe*. \n\n**Objective**. The goal is to approximate the reach-pipe, $\\jR_{[0,T]} (X_0)$, given an initial set $X_0$ and a finite time horion $T>0$."}
{"cell_type":"markdown","metadata":{},"source":"### 3.1. Time-discretization scheme\n\nThe approach is based on the discretization of time. Let $\\tau = T/N$ be the time step. Then,\n$$\n\\jR_{[0,T]} (X_0) = \\bigcup\\limits_{i=0}^{N-1} \\jR_{[i\\tau, (i+1)\\tau]} (X_0).\n$$\nThe idea is to compute over-approximations of the sets $\\jR_{[i\\tau, (i+1)\\tau]} (X_0)$, and the desired result will be their union."}
{"cell_type":"markdown","metadata":{},"source":"### 3.2. Main result \n\nThe idea is that the reachable set $\\jR_{[0,T]} (X_0)$ can be approximated by the union of convex sets $\\Omega_0 \\cup \\ldots \\cup \\Omega_{N-1}$. The sequence of approximants is built as\n$$\n\\Omega_0 := CH\\left(X_0, e^{\\tau A}X_0 \\oplus \\tau V \\oplus \\alpha_{\\tau} B \\right),\n$$\nand\n$$\n\\Omega_{i+1} := CH\\left( X_0, e^{\\tau A}\\Omega_i \\oplus \\tau V \\oplus \\beta_{\\tau} B\\right),\\qquad i = 0,\\ldots,N-2.\n$$\nIn these definitions, $\\alpha_{\\tau}$ and $\\beta_{\\tau}$ have explicit formulas which are such that over-approximation is ensured. The main result is that the error bound can be made arbitrarily small by choosing $\\tau$ small enough. More precisely (see Theorem 1 in [LGG09](http://www-ljk.imag.fr/membres/Antoine.Girard/Publications/na-hs.pdf) for details), for all $i=0,\\ldots,N-1$, it holds that\n$$\nd^H(\\Omega_i, \\jR_{[i\\tau,(i+1)\\tau]} (X_0)) \\leq \\tau e^{T||A||} \\left( \\dfrac{||A||}{4} D_{X_0} + \\tau ||A||^2  R_{X_0} + e^{\\tau ||A||} R_V \\right), \n$$\nwhere $R_{X_0}$ and $R_V$ are the radius of $X_0$ and $V$ respectively, and $D_{X_0}$ is the diameter of $X_0$. Note that the error bound for the Hausdorff distance is in $\\mathcal{O}(\\tau)$."}
{"cell_type":"markdown","metadata":{},"source":"### 3.3. Implementation of the algorithm"}
{"cell_type":"markdown","metadata":{},"source":"The initial set that we are given is $\\mathcal{X}_0 = [0.9,1.1]\\times [-0.1,1.1] = B_\\infty([1,0],0.1)$."}
{"cell_type":"code","execution_count":129,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"reset()"}
{"cell_type":"code","execution_count":130,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"import numpy as np\nfrom scipy.linalg import expm, sinm, cosm\nload(\"../Library/polyFunctions.sage\")\nload(\"../Library/matrixNorms.sage\")\n\n# LTI system\nn = 2\nA = np.array([[-1, -4], [4, -1]], dtype=float) \nB = np.array([[1, 0], [0, 1]], dtype=float)\n\n# time horizon, t0=0 is assumed\nT = 2\n\n# input domain U\nmu = 0.05\nU = Binfty(center = [0,0], radius = mu)\n\n# initial condition \nX0 = Binfty(center = [1,0], radius = 0.1)\n\n# time discretization \ntau = 1e-1\nN = 20 # in the analysis, T = N*tau\n# compute range of the input under B, V = BU\nV = matTimesPol(B, U) \n\n# compute matrix exponential \nPhi_tau = expm(np.multiply(A, tau))\n\n# compute exp(tau*A)X0\nexpX0 = matTimesPol(Phi_tau, X0)\n\n# compute the initial over-approximation\ntau_V = matTimesPol(tau*np.identity(n), V)\n\n# compute the bloating factor \nAinfty = matinftynorm(A)\nRX0 = polyRadius(X0)\nRV = polyRadius(V)\n\nunitBall = Binfty(center = [0,0], radius = 1)\nalpha_tau = (exp(tau*Ainfty) - 1 - tau*Ainfty)*(RX0 + RV/Ainfty)\nalpha_tau_B = matTimesPol(alpha_tau*np.identity(n), unitBall)\n\n# compute the first element of the approximating sequence, Omega_0\naux = expX0.Minkowski_sum(tau_V)\nOmega0 = X0.convex_hull(aux.Minkowski_sum(alpha_tau_B)) "}
{"cell_type":"markdown","metadata":{},"source":"Here $\\Omega_0$ is an over-approximation $\\jR_{[0,\\tau]}(X_0)$. The idea is the following:\n1. $e^{\\tau A}X_0 \\oplus \\tau V$ is an approxmation of the reachable set at time $\\tau$;\n2. a *bloating* operation followed by a convex hull operation gives an approxmation of $\\jR_{[0,\\tau]}(X_0)$. \n3. $\\alpha_\\tau$ (the bloating factor) is chosen to ensure over-approxmation. \n\nLet us check $\\Omega_0$:"}
{"cell_type":"code","execution_count":112,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"image/png":"smc-blob::7f3de489-89eb-40ce-8a80-df6106b32067","text/plain":"Graphics object consisting of 17 graphics primitives"},"execution_count":112,"metadata":{},"output_type":"execute_result"}],"source":"Omega0.plot(alpha=0.5) + X0.plot(alpha=0.7,color='blue')"}
{"cell_type":"code","execution_count":131,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"# build the Omega_i\nbeta_tau = (exp(tau*Ainfty) - 1 - tau*Ainfty)*(RV/Ainfty)\nbeta_tau_B = matTimesPol(beta_tau*np.identity(n), unitBall)\nW_tau = tau_V.Minkowski_sum(beta_tau_B) \n\n# receives a direction d, and outputs the support function rho_i of Omega_i at d\ndef Omega_i_supports(d, N):\n    r = list()\n    s = list()\n    rhoi = list()\n    \n    r.append(d)\n    s.append(0)\n    rhoi.append(supp_fun_polyhedron(d,Omega0,showOutput=0)[0])\n    \n    for i in [0..N-2]:\n        r.append(np.dot(Phi_tau.transpose(),r[i]))\n        s.append(s[i] + supp_fun_polyhedron(r[i], W_tau,showOutput=0)[0])\n        rhoi.append(s[i+1] + supp_fun_polyhedron(r[i+1], Omega0, showOutput=0)[0])\n    \n    return rhoi"}
{"cell_type":"code","execution_count":132,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"# define the directions \n\n# directions at random\n#import random\n#k=4\n#theta = [random.uniform(0, 2*pi.n(digits=5)) for i in range(k)]\n#d = [vector(RR,[cos(theta[i]), sin(theta[i])]) for i in range(k)]\n\n# specify directions \n#theta = [0,pi/2,pi,3*pi/2] # box\ntheta = [i*pi/4 for i in [0..7]] # octagon\n\ndList = [vector(RR,[cos(theta[i]), sin(theta[i])]) for i in range(len(theta))]\ndArray = np.array(dList)\n\n# number of directions\nk = len(dArray)\n\n# compute family of support functions\nOmega_i_Family_SF = list()\nfor i in range(len(dArray)):\n    d = dArray[i]\n    Omega_i_Family_SF.append( Omega_i_supports(d, N) ) "}
{"cell_type":"markdown","metadata":{},"source":"### 3.5. Test of the implementation\n\nIt remains to build the family of approximating polyhedrons, and plot the result."}
{"cell_type":"code","execution_count":133,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"# build each polyhedron using the support functions over-approximation\n# we have N polyhedrons\nOmega_i_Poly = list()\nfor i in range(N): #run over polytopes\n    \n    # for each polyhedra, I have to use all directions that I know\n    A = matrix(RR,k,n); b = vector(RR,k)\n    for j in range(k): #run over directions\n        s_fun = Omega_i_Family_SF[j][i]\n        A.set_row(j, dList[j])\n        b[j] = s_fun\n        \n    Omega_i_Poly.append( polytopeFromHrep(A, b) ) "}
{"cell_type":"code","execution_count":134,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"# plot the result\nmyFig = Graphics()"}
{"cell_type":"code","execution_count":140,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"image/png":"smc-blob::cc8926e8-1613-476a-af59-cbcda1e89504","text/plain":"Graphics object consisting of 21 graphics primitives"},"metadata":{},"output_type":"display_data"}],"source":"# sanity check\nmyFig = Omega_i_Poly[0].plot(alpha=0.5,color='red') + Omega0.plot(alpha=0.5,color='blue')\nmyFig.show()\n# we don't actually expect exact matching (because Omega0 is being partially constructed with its support function); unless we take sufficient number of directions"}
{"cell_type":"code","execution_count":137,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"image/png":"smc-blob::97a01808-e7e6-4ca9-8834-0e71eaa323fd","text/plain":"Graphics object consisting of 200 graphics primitives"},"metadata":{},"output_type":"display_data"}],"source":"myFig = Omega_i_Poly[0].plot(alpha=0.5,color='red') + sum(Omega_i_Poly[i].plot(alpha=0.5) for i in [1..N-1])\nmyFig.show()"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":""}