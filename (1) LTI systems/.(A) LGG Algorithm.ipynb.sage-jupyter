{"kernelspec":{"display_name":"SageMath 6.10","language":"","name":"sagemath"},"language_info":{"codemirror_mode":{"name":"ipython","version":2},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython2","version":"2.7.10"}}
{"cell_type":"markdown","metadata":{},"source":"$\\newcommand{\\R}{\\mathbb{R}}$\n$\\newcommand{\\transp}{\\mathrm{T}}$"}
{"cell_type":"markdown","metadata":{"collapsed":false},"source":"# B. The LGG Algorithm\n\n[SpaceEx](http://spaceex.imag.fr/) is a verification platform for hybrid systems. The basic functionality is to compute the set of reachable sets of a system. Currently, SpaceEx accepts piecewise-linear systems only. The standard way to deal with nonlinearities is to perform a local linearization of the system's dynamics, a method called *hybridization* in this area.  \n \nThe [LGG (Le Guernic-Girard)](http://ljk.imag.fr/membres/Antoine.Girard/Publications/cav2009.pdf) is an algorithm implemented in SpaceEx (along with more recent methods such as [STC](http://spaceex.imag.fr/sites/default/files/frehse_stc_lgg_comp.pdf)).  \n\nIn this worksheet we implement the linear part of the LGG algorithm of Le Guernic and Girard, described in [this paper](http://www-ljk.imag.fr/membres/Antoine.Girard/Publications/na-hs.pdf), and make a test in the following simple example. "}
{"cell_type":"markdown","metadata":{"collapsed":false},"source":"## 1. Context\n\nstatement of the problem (with control and all stuff) \n\ngeneralities about guaranteed verification"}
{"cell_type":"markdown","metadata":{},"source":"### 1.1 Motivating example\n\nxxxx"}
{"cell_type":"markdown","metadata":{},"source":"## 2. Hybridization\n\nThe method known as hybridization consists in performing a local linearization over a set of positions in state-space. \n\nThis is an illustration of the hybridization technique, from [O. Maler, Computing Reachable Sets: An Introduction](http://www-verimag.imag.fr/~maler/Papers/reach-intro.pdf).\n![alt text](https://github.com/mforets/SMC-and-set-based-computations/blob/master/fig/hybridization.png?raw=true)"}
{"cell_type":"markdown","metadata":{},"source":"## 3. The journey begins: intution on a \"quasi-linear impulsive system\"\n\nThe method known as hybridization consists in performing a local linearization over a set of positions in state-space. \n"}
{"cell_type":"markdown","metadata":{"collapsed":true},"source":"## 4. Two-dimensional LTI example \n\nConsider the system\n$$\n\\begin{pmatrix}\n\\dot{x}_1 \\\\ \\dot{x}_2\n\\end{pmatrix} = \\begin{pmatrix} -1  & -4 \\\\ 4 & -1 \\end{pmatrix} \\begin{pmatrix}\nx_1 \\\\ x_2\n\\end{pmatrix} + \\begin{pmatrix} u_1 \\\\ u_2 \\end{pmatrix}.\n$$\nLet $\\mathcal{X}_0 = [0.9,1.1]\\times [-0.1,1.1]$ be the initial set. Suppose that $u_1(t),u_2(t) \\in B_\\infty(0,\\mu)$ for all $t\\geq 0$, with $\\mu=0.05$. What is the set of states reachable at time $T=2$? This two-dimensional example appears in [Gir05](http://www-ljk.imag.fr/membres/Antoine.Girard/Publications/hscc2005.pdf])."}
{"cell_type":"markdown","metadata":{},"source":"## 4.1. Numerical integration \n\nThe solution of the [LTI](https://en.wikipedia.org/wiki/LTI_system_theory) system $\\dot{x}=Ax + u$ is\n$$\nx(t) = e^{At}x_0 + \\int_0^t e^{A(t-s)}u(s) ds,\n$$\nwhere $x=(x_1,x_2)^\\transp$ and $u = (u_1, u_2)^\\transp$. Below we numericlly solve this integral for different values of the initial condition. Let us assume that $u_1(t) =U_{max} \\cos t$ and $u_2(t) = U_{max} \\sin t$, with $U_{max} = 1/2$."}
{"cell_type":"code","execution_count":104,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"%display typeset\n# numerical integral \n\n# define input\nvar('t')\nUmax = 1/2\nu1 = Umax*cos(t)\nu2 = Umax*sin(t)\n\n"}
{"cell_type":"markdown","metadata":{},"source":"## A.5 Efficient algorithm for the computation of polyhedral approximations of the reachable set \n\nThis corresponds to Section 4 of [LGG09](http://www-ljk.imag.fr/membres/Antoine.Girard/Publications/na-hs.pdf). \n"}
{"cell_type":"markdown","metadata":{},"source":"### A.5.1 Introduction\n\n"}
{"cell_type":"markdown","metadata":{},"source":"### A.5.3 Outline of the algorithm \n\n1. Compute matrix $\\Phi_\\tau$."}
{"cell_type":"markdown","metadata":{},"source":"### A.5.4 Main results (optional)\n"}
{"cell_type":"markdown","metadata":{},"source":"### A.5.5 Implementation\n"}
{"cell_type":"markdown","metadata":{},"source":"The initial set that we are given is $\\mathcal{X}_0 = [0.9,1.1]\\times [-0.1,1.1] = B_\\infty([1,0],0.1)$."}
{"cell_type":"code","execution_count":1,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"ename":"NameError","evalue":"name 'supp_fun_polyhedron' is not defined","output_type":"error","traceback":["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m","\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)","\u001b[1;32m<ipython-input-1-6ac686f562b8>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[0;32m     20\u001b[0m \u001b[0mtheta\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mrandom\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0muniform\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mInteger\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mInteger\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m2\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m*\u001b[0m\u001b[0mpi\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mn\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mdigits\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mInteger\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m5\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     21\u001b[0m \u001b[0md\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mvector\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mRR\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;33m[\u001b[0m\u001b[0mcos\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mtheta\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0msin\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mtheta\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m---> 22\u001b[1;33m \u001b[0ms\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0msupp_fun_polyhedron\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0md\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mX0\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mshowOutput\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mInteger\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m","\u001b[1;31mNameError\u001b[0m: name 'supp_fun_polyhedron' is not defined"]}],"source":"import numpy as np\nfrom scipy.linalg import expm, sinm, cosm\nload(\"../Library/polyFunctions.sage\")\n\n# LTI system\nA = np.matrix([[-1, -4], [4, -1]], dtype=float) \n\n# input domain U\nmu = 0.05\nU = Binfty(center = [0,0], radius = mu)\n\n# initial condition \nX0 = Binfty(center = [1,0], radius = 0.1)\n\n# time discretization \ntau = 1e-1\n\n# define a set of random directions \nimport random\ntheta = random.uniform(0, 2*pi.n(digits=5))\nd = vector(RR,[cos(theta), sin(theta)])\ns = supp_fun_polyhedron(d, X0, showOutput=0)"}
{"cell_type":"code","execution_count":196,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"# compute matrix exponential \nPhi_tau = expm(np.multiply(A, tau))\n\n# compute exp(tau*A)X0\nvertices_X0 = X0.vertices_list()\nvertices_expX0 = [np.dot(Phi_tau,vertices_X0[i]) for i in range(len(vertices_X0))]\nexpX0 = Polyhedron(vertices = expX0,base_ring=RDF)\n\n# compute the initial over-approximation\ntau_V = \nalpha_tau_B = \naux = expX0.Minkowski_sum(tau_V)\nOmega0 = X0.convex_hull(aux.Minkowski_sum(alpha_tau_B)) "}
{"cell_type":"code","execution_count":191,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\verb|[|\\phantom{\\verb!x!}\\verb|0.78530544|\\phantom{\\verb!xx!}\\verb|0.23378321]|</script></html>","text/plain":"array([ 0.78530544,  0.23378321])"},"execution_count":191,"metadata":{},"output_type":"execute_result"}],"source":""}