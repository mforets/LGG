{"kernelspec":{"display_name":"SageMath 6.10","language":"","name":"sagemath"},"language_info":{"codemirror_mode":{"name":"ipython","version":2},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython2","version":"2.7.10"}}
{"cell_type":"markdown","metadata":{},"source":"$\\newcommand{\\R}{\\mathbb{R}}$\n$\\newcommand{\\transp}{\\mathrm{T}}$"}
{"cell_type":"markdown","metadata":{"collapsed":false},"source":"# A. LGG Algorithm\n\n[SpaceEx](http://spaceex.imag.fr/) is a verification platform for hybrid systems. The basic functionality is to compute the set of reachable sets of a system. Currently, SpaceEx accepts piecewise-linear systems only. The standard way to deal with nonlinearities is to perform a local linearization of the system's dynamics, a method called *hybridization* in this area.  \n \nThe [LGG (Le Guernic-Girard)](http://ljk.imag.fr/membres/Antoine.Girard/Publications/cav2009.pdf) is an algorithm implemented in SpaceEx (along with more recent methods such as [STC](http://spaceex.imag.fr/sites/default/files/frehse_stc_lgg_comp.pdf)).  \n\nIn this worksheet we implement the linear part of the LGG algorithm of Le Guernic and Girard, described in [this paper](http://www-ljk.imag.fr/membres/Antoine.Girard/Publications/na-hs.pdf), and make a test in the following simple example. "}
{"cell_type":"markdown","metadata":{"collapsed":false},"source":"## A.1 Context\n\nstatement of the problem (with control and all stuff) \n\ngeneralities about guaranteed verification"}
{"cell_type":"markdown","metadata":{},"source":"### A.1.1 Motivating example\n\nxxxx"}
{"cell_type":"markdown","metadata":{},"source":"## A.2 Hybridization\n\nThe method known as hybridization consists in performing a local linearization over a set of positions in state-space. \n\nThis is an illustration of the hybridization technique, from [O. Maler, Computing Reachable Sets: An Introduction](http://www-verimag.imag.fr/~maler/Papers/reach-intro.pdf).\n![alt text](https://github.com/mforets/SMC-and-set-based-computations/blob/master/fig/hybridization.png?raw=true)"}
{"cell_type":"markdown","metadata":{},"source":"## A.3 The journey begins: intution on a \"quasi-linear impulsive system\"\n\nThe method known as hybridization consists in performing a local linearization over a set of positions in state-space. \n"}
{"cell_type":"markdown","metadata":{"collapsed":true},"source":"## A.4 Two-dimensional LTI example \n\nConsider the system\n$$\n\\begin{pmatrix}\n\\dot{x}_1 \\\\ \\dot{x}_2\n\\end{pmatrix} = \\begin{pmatrix} -1  & -4 \\\\ 4 & -1 \\end{pmatrix} \\begin{pmatrix}\nx_1 \\\\ x_2\n\\end{pmatrix} + \\begin{pmatrix} u_1 \\\\ u_2 \\end{pmatrix}.\n$$\nLet $\\mathcal{X}_0 = [0.9,1.1]\\times [-0.1,1.1]$ be the initial set. Suppose that $u_1(t),u_2(t) \\in B_\\infty(0,\\mu)$ for all $t\\geq 0$, with $\\mu=0.05$. What is the set of states reachable at time $T=2$? This two-dimensional example appears in [Gir05](http://www-ljk.imag.fr/membres/Antoine.Girard/Publications/hscc2005.pdf])."}
{"cell_type":"markdown","metadata":{},"source":"## A.4.1 Numerical integration \n\nThe solution of the [LTI](https://en.wikipedia.org/wiki/LTI_system_theory) system $\\dot{x}=Ax + u$ is\n$$\nx(t) = e^{At}x_0 + \\int_0^t e^{A(t-s)}u(s) ds,\n$$\nwhere $x=(x_1,x_2)^\\transp$ and $u = (u_1, u_2)^\\transp$. Below we numericlly solve this integral for different values of the initial condition. Let us assume that $u_1(t) =U_{max} \\cos t$ and $u_2(t) = U_{max} \\sin t$, with $U_{max} = 1/2$."}
{"cell_type":"code","execution_count":104,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"%display typeset\n# numerical integral \n\n# define input\nvar('t')\nUmax = 1/2\nu1 = Umax*cos(t)\nu2 = Umax*sin(t)\n\n"}
{"cell_type":"markdown","metadata":{},"source":"## A.4.2 Support function\n\nLet $\\Omega \\subset \\mathbb{R}^n$ be a compact convex set. The support function of $\\Omega$, $\\rho_\\Omega : \\mathbb{R}^n \\to \\mathbb{R}$, is defined as \n\\begin{equation}\n\\rho_\\Omega(d) = \\max_{x \\in \\Omega}~~ d^\\mathrm{T}\\cdot x\n\\end{equation}\n"}
{"cell_type":"markdown","metadata":{},"source":"### A.4.2.1 Support function of a convex polytope\n\nIf $\\Omega$ is a convex polytope, $\\Omega = \\{ x \\in \\mathbb{R}^n:~Ax \\leq b\\}$, then its support function is equivalent to solving the [linear program](https://en.wikipedia.org/wiki/Linear_programming) (LP):\n\\begin{equation}\n\\rho_\\Omega(d) = \\text{max} \\{ d^\\mathrm{T}\\cdot x :~ Ax \\leq b \\}\n\\end{equation}\nBelow we implement this function. The class Polyhedron saves the inequalities as [b,A], with the convention that $Ax+b\\geq 0$, so we have to be careful if we use the convention $Ax \\leq b$."}
{"cell_type":"code","execution_count":22,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"#Compute support function of a convex polytope (given as (A,b), assuming: Ax <= b)\ndef supp_fun_polyhedron(d, P, showOutput=1): \n    \n    s_LP = MixedIntegerLinearProgram(maximization=True, solver = \"GLPK\")\n    x = s_LP.new_variable(integer=False, nonnegative=False)\n\n    # objective function\n    obj = sum(d[i]*x[i] for i in range(len(d)))\n    s_LP.set_objective(obj)\n    \n    # extract the constraints from P\n    m = len(P.Hrepresentation())\n    n = len(vector( P.Hrepresentation()[0] ))-1\n    b = vector(RR, m)\n    A = matrix(RR, m, n)\n    P_gen = P.Hrep_generator();\n    i=0\n    for pigen in P_gen:\n        pi_vec = pigen.vector()\n        A.set_row(i, -pi_vec[1:len(pi_vec)])\n        b[i] = pi_vec[0]\n        i+=1;\n        \n    s_LP.add_constraint(A * x <= b);    \n        \n    if (showOutput):\n        print '**** Solve LP (using GLPK) ****'    \n        s_LP.show()\n    \n    oval = s_LP.solve()\n    xopt = s_LP.get_values(x);\n    \n    if (showOutput):\n        print 'Objective Value:', oval\n        for i, v in xopt.iteritems():\n            print 'x_%s = %f' % (i, v)\n        print '\\n'\n    return oval, xopt"}
{"cell_type":"markdown","metadata":{},"source":"### A.4.2.2 Support function of an ellipse \n\n*Exercise*. What is the support function of an ellipsoid? \n\n*Answer*. Let $E = \\{ x \\in \\R^n : x^\\transp Q x \\leq 1\\}$, where $Q$ is a positive definite symmetric matrix. Then, $\\rho_E(d) = \\sqrt{d^\\transp Q^{-1} d}$."}
{"cell_type":"code","execution_count":86,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"#Compute support function at d of an ellipse input as x^tr*Q*x <= 1\ndef supp_fun_ellipse(d, Q, showOutput=1): \n    if (Q.is_singular()):\n        print 'error: input matrix is not invertible'\n        return\n    return sqrt(d.inner_product((~Q)*d))\n    "}
{"cell_type":"code","execution_count":53,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"image/png":"smc-blob::34d15f64-0638-4ea9-a554-aa08825b4b75","text/plain":"Graphics object consisting of 1 graphics primitive"},"execution_count":53,"metadata":{},"output_type":"execute_result"}],"source":"# build an ellipse centred at 0, with semiaxes 3 and 1, and tilted 30 deg counterclockwise\nE = ellipse((0,0),3,1,pi/6,fill=True,edgecolor='black',facecolor='red',rgbcolor='green',alpha=0.3)\nE"}
{"cell_type":"markdown","metadata":{},"source":"As shown in the previous cell, sagemath provides a command to plot an ellipse given the semiaxes and at a given angle wrt the coordinates axes. However I didn't find how to extract the $Q$ in one stroke (though this can be easily achieved [through a change of variables](http://www.maa.org/external_archive/joma/Volume8/Kalman/General.html)). Let us instead build the ellipse ourselves. In the way we will encounter the *implicit plot* feature."}
{"cell_type":"code","execution_count":103,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"image/png":"smc-blob::84c490d7-3539-4c9e-a14f-4b2f4b499723","text/plain":"Graphics object consisting of 10 graphics primitives"},"execution_count":103,"metadata":{},"output_type":"execute_result"}],"source":"# Generate a random ellipsoid and plot using implicit plot\nimport random\n\n# define an ellipse as: x^tr*Q*x <= 1\nM = random_matrix(RR, 2, distribution=\"uniform\")\nQ = M.T*M\nf = lambda x, y : Q[0,0]*x^2 + Q[1,1]*y^2 + (Q[0,1]+Q[1,0])*x*y-1\nE = implicit_plot(f,(-5,5),(-3,3),fill=True,alpha=0.5,plot_points=600)\n\n# Try out the overapproximation of an ellipse using support functions\nimport numpy as np\nload(\"../Library/polyFunctions.sage\")\n\n# generate at random k directions, and compute the overapproximation of E using support functions\n# works 'in average': we might get unbounded domains in some cases / 'frozen set'\nk=8\nA = matrix(RR,k,2); b = vector(RR,k)\nfor i in range(k):\n    theta = random.uniform(0, 2*pi.n(digits=5))\n    d = vector(RR,[cos(theta), sin(theta)])\n    s_fun = supp_fun_ellipse(d, Q, showOutput=0)\n    A.set_row(i,d); b[i] = s_fun\n\nOmegaApprox = polytopeFromHrep(A, b)\nE + OmegaApprox.plot(fill=False, color='red')"}
{"cell_type":"markdown","metadata":{},"source":"## A.5 Efficient algorithm for the computation of polyhedral approximations of the reachable set \n\nThis corresponds to Section 4 of [LGG09](http://www-ljk.imag.fr/membres/Antoine.Girard/Publications/na-hs.pdf). \n"}
{"cell_type":"markdown","metadata":{},"source":"### A.5.1 Introduction\n\n"}
{"cell_type":"markdown","metadata":{},"source":"### A.5.2 Hausdorff distance and norms \n\nRecall that the $p$-norm of $x \\in \\R^n$ ($1\\leq p <\\infty$) is $||x||_p = \\left( \\sum_i |x_i|^p \\right)^{1/p}$; the supremum norm ($p=\\infty$) is $||x||_\\infty = \\max_i |x_i|$. The reason of the constraint $p \\geq 1$ is due to the fact that we loose convexity if we allow $p<1$. In most applications, convexity is a desired property. This is illustrated in the figures below:\n![alt text](http://upload.wikimedia.org/wikipedia/commons/e/e6/Minkowski3.png \"p-norm\")\n\nThe [Hausdorff distance](https://en.wikipedia.org/wiki/Hausdorff_distance) is a concept that generalizes the notion of distance between points, to distance between *sets of points*. To understand why we need a generalization, think of the following: what would be a reasonable distance between the yellow semidisk and the orange line? between the blue line and the semidisk? between both lines?"}
{"cell_type":"code","execution_count":176,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"image/png":"smc-blob::342ba7be-78e1-45be-a90c-7913e44535ce","text/plain":"Graphics object consisting of 3 graphics primitives"},"execution_count":176,"metadata":{},"output_type":"execute_result"}],"source":"disk((0.0,0.0), 1, (pi/4,3*pi/4) ,rgbcolor=(1,1,0)) + line([[0.2,0.5], [1.5,0.5]]) + line([[-0.6,1.1], [0.6,1.1]],color='orange')"}
{"cell_type":"markdown","metadata":{},"source":"More precisely, in the Euclidean space $(\\R^n,||\\cdot||_p)$ the Hausdorff distance between the sets $X$ and $Y$ is defined as\n$$\nd^H_p(X,Y) = \\max \\left\\{ \\sup_{x \\in X} \\inf_{y \\in Y} ||x-y||_p , \\sup_{y \\in Y} \\inf_{x \\in X} ||x-y||_p \\right\\}.\n$$\nIt is worth doing some examples by hand to convince you that this formulation makes sense.\n\n*Exercise*. Answer the questions in relation to the previous plot using the definition of Hausdorff distance, with $p=2$ (usual Euclidean norm). How does the result change with different values of $p$?"}
{"cell_type":"markdown","metadata":{},"source":""}
{"cell_type":"markdown","metadata":{},"source":"### A.5.3 Outline of the algorithm \n\n1. Compute matrix $\\Phi_\\tau$."}
{"cell_type":"markdown","metadata":{},"source":"### A.5.4 Main results (optional)\n"}
{"cell_type":"markdown","metadata":{},"source":"### A.5.5 Implementation\n"}
{"cell_type":"markdown","metadata":{},"source":"The initial set that we are given is $\\mathcal{X}_0 = [0.9,1.1]\\times [-0.1,1.1] = B_\\infty([1,0],0.1)$."}
{"cell_type":"code","execution_count":181,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"import numpy as np\nfrom scipy.linalg import expm, sinm, cosm\nload(\"../Library/polyFunctions.sage\")\n\n# LTI system\nA = np.matrix([[-1, -4], [4, -1]], dtype=float)\nmu = 0.05 \n\n# initial condition \nX0 = Binfty(center = [1,0], radius = 0.1)\n\n# time discretization \ntau = 1e-1\n\n# define a set of random directions \nimport random\ntheta = random.uniform(0, 2*pi.n(digits=5))\nd = vector(RR,[cos(theta), sin(theta)])\ns = supp_fun_polyhedron(d, X0, showOutput=0)"}
{"cell_type":"code","execution_count":182,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"# compute matrix exponential \nexpBB = expm(np.multiply(A, tau))\n"}
{"cell_type":"code","execution_count":179,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\begin{array}{l}\n\\verb|[[|\\phantom{\\verb!x!}\\verb|1.|\\phantom{\\verb!xx!}\\verb|2.]|\\\\\n\\phantom{\\verb!x!}\\verb|[|\\phantom{\\verb!x!}\\verb|3.|\\phantom{\\verb!xx!}\\verb|4.]]|\n\\end{array}</script></html>","text/plain":"matrix([[ 1.,  2.],\n        [ 3.,  4.]])"},"execution_count":179,"metadata":{},"output_type":"execute_result"}],"source":"Phir"}
{"cell_type":"code","execution_count":180,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\begin{array}{l}\n\\verb|[[|\\phantom{\\verb!x!}\\verb|1.|\\phantom{\\verb!xx!}\\verb|2.]|\\\\\n\\phantom{\\verb!x!}\\verb|[|\\phantom{\\verb!x!}\\verb|3.|\\phantom{\\verb!xx!}\\verb|4.]]|\n\\end{array}</script></html>","text/plain":"array([[ 1.,  2.],\n       [ 3.,  4.]])"},"execution_count":180,"metadata":{},"output_type":"execute_result"}],"source":"np.array([[1, 2], [3, 4]], dtype=float)"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":""}