# This file was *autogenerated* from the file norms.sage
from sage.all_cmdline import *   # import sage library
_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0)
r"""
Extension to polyhedra library for the purpose of mathematical modeling, with a focus on computational geometry.

matrixNorms has methods to compute:

* matrix norm, induced by vector p-norms, for the simplest cases p = 1, 2, infty.

* the vector p norm for 1 <=p < infty with vecpnorm(b,p) and vecinftynorm(b) for p = infty

AUTHORS:

- Marcelo Forets (last modified 2016-10-20)

TO-DO:

The general case for a matrix norm. See:
http://mathoverflow.net/questions/39148/efficiently-computing-a-matrixs-induced-p-norm

"""

#*****************************************************************************
#       Copyright (C) 2016 Marcelo Forets <mforets@nonlinearnotes.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************

import numpy as np

def matrix_1_norm(A):

    aux = _sage_const_0 
    for j in range(A.ncols()):
        aux2=_sage_const_0 
        for i in range(A.nrows()):
            aux2 += abs(A[i,j])
        if (aux2 > aux):
            aux = aux2

    return aux

def matrix_sup_norm(A):

    try:
        [nrows, ncols] = A.shape
    except:
        nrows = A.nrows(); ncols = A.ncols()

    aux = _sage_const_0 
    for i in range(nrows):
        aux2=_sage_const_0 
        for j in range(ncols):
            aux2 += abs(A[i,j])
        if (aux2 > aux):
            aux = aux2

    return aux

def matrix_2_norm(A):
    Q = A.H*A
    eval, evec = np.linalg.eig(Q.change_ring(RR))
    aux = sqrt(np.max(eval))

    return aux


def vector_1_norm(b):
    aux = _sage_const_0 
    for i in range(len(b)):
        aux += abs(b[i])

    return aux


def vector_sup_norm(b):
    aux = _sage_const_0 
    for i in range(len(b)):
        if (abs(b[i]) > aux):
            aux = abs(b[i])

    return aux


def vector_2_norm(b):
    aux = _sage_const_0 
    for i in range(len(b)):
        aux += b[i]**_sage_const_2 

    return sqrt(aux)

# p is a number: 1 <= p <= infty
def vector_p_norm(b,p):
    aux = _sage_const_0 

    if (p == 'inf'):
        for i in range(len(b)):
            if (abs(b[i]) > aux):
                aux = abs(b[i])

    else:    # if p < infty
        for i in range(len(b)):
            aux += abs(b[i])**p
        aux = aux**(_sage_const_1 /p)

    return aux
