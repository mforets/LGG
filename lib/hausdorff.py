# This file was *autogenerated* from the file hausdorff.sage
from sage.all_cmdline import *   # import sage library
_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_1en1 = RealNumber('1e-1'); _sage_const_1e2 = RealNumber('1e2'); _sage_const_0 = Integer(0); _sage_const_6 = Integer(6)
r"""
Extension to polyhedra library for the purpose of mathematical modeling, with a focus on computational geometry.

hausdorff.sage stands for Hausdorff distance approximation.
Contains functions to estimate Hausdorff distance between polytopes in different setups.

AUTHORS:

- Marcelo Forets (last modified 2016-10-20)

- Frederic Viry

EXAMPLES::

See 'Examples-polyFunctions-core.ipynb'
See '~/Projects/Compositional/dHp qblocks some tests.ipynb'

"""

#*****************************************************************************
#       Copyright (C) 2016 Marcelo Forets <mforets@nonlinearnotes.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************

from polyFunctions_core import *
from norms import *

class NotImplementedException(Exception):
    def __init__(self, msg):
        self.msg = msg
    def __str__(self):
        return self.msg


def polyAsphericity(P, tol=_sage_const_1en1 , MaxIter = _sage_const_1e2 , verbose=_sage_const_0 ):

    # check low-dimensionality
    if not P.is_full_dimensional(): raise NotImplementedException('The polytope is not full-dimensional')

    # initial data
    p = P.ambient_dim()

    [DP, d] = polytopeToHrep(P) # in the form Dy <= d
    D = -DP    # transform to <Dj,y> + dj >= 0
    l = D.nrows()
    mP = oppositePolytope(P)

    # unit ball, infinity norm
    Bn = Binfty(zero_vector(RR,p), _sage_const_1 )
    [C, c] = polytopeToHrep(Bn)
    C = -C    # transform to <Cj,y> + cj >= 0
    m = len(c)

    # auxiliary matrices A, a, B, b
    A = matrix(RR, C.nrows(), C.ncols())
    a = []
    for i in range(m):
        A.set_row(i, -C.row(i)/c[i])
        a.append(supp_fun_polyhedron(A.row(i), mP, showOutput=_sage_const_0 )[_sage_const_0 ])

    B = matrix(RR, D.nrows(), D.ncols())
    b = []
    for j in range(l):
        [nDj, ymax] = supp_fun_polyhedron(D.row(j), Bn, showOutput=_sage_const_0 )
        B.set_row(j, D.row(j)/nDj)
        b.append(d[j]/nDj)

    #[psi_k, alphakList, xkList] = asphericityPolytope(x0)

    # generate an initial point
    x0 = chebyshev_center(DP, d)

    # compute asphericity at x0
    R = max(A.row(i)*vector(x0)+a[i] for i in range(m))
    r = min(B.row(j)*vector(x0)+b[j] for j in range(l))
    alpha0 = R/r

    xkList = [vector(x0)]
    alphakList = [alpha0]

    xk0 = x0; psi_k0 = alpha0
    alphak0 = alpha0
    convergeFlag = _sage_const_0 
    iterCount = _sage_const_0 
    while (iterCount < MaxIter) and (not convergeFlag):
        [psi_k, xkDict, zkDict] = asphericity_iteration(xk0, l, m, p, A, a, B, b, verbose)
        xk = vector(xkDict); xkList.append(xk)
        zk = vector(zkDict); alphakList.append(zk[_sage_const_0 ])
        xk0 = xk;
        if (abs(psi_k - psi_k0) < tol):
            convergeFlag = _sage_const_1 
        psi_k0 = psi_k
        iterCount += _sage_const_1 

    x_asph = xkList.pop()
    R_asph = max(A.row(i)*vector(x_asph)+a[i] for i in range(m))
    r_asph = min(B.row(j)*vector(x_asph)+b[j] for j in range(l))
    asph = R_asph/r_asph

    return [asph, x_asph]


def asphericity_iteration(xk, l, m, p, A, a, B, b, verbose = _sage_const_0 ):
    # what is the best way to share this data?

    #alphak = asphericity(xk)
    R_xk = max(A.row(i)*vector(xk)+a[i] for i in range(m))
    r_xk = min(B.row(j)*vector(xk)+b[j] for j in range(l))
    alphak = R_xk/r_xk

    a_LP = MixedIntegerLinearProgram(maximization=False, solver = "GLPK")
    x = a_LP.new_variable(integer=False, nonnegative=False)
    z = a_LP.new_variable(integer=False, nonnegative=False)

    for i in range(m):
        for j in range(l):
            aux = sum( (A.row(i)[k]-alphak*B.row(j)[k])*x[k] for k in range(p))
            a_LP.add_constraint(aux + a[i] - alphak*b[j] <= z[_sage_const_0 ]);

    #solve LP
    a_LP.set_objective(z[_sage_const_0 ])

    if (verbose):
        print '**** Solve LP (using GLPK) ****'
        a_LP.show()

    opt_val = a_LP.solve()

    x_opt = a_LP.get_values(x);
    z_opt = a_LP.get_values(z)

    if (verbose):
        print 'Objective Value:', opt_val
        for i, v in x_opt.iteritems():
            print 'x_%s = %f' % (i, v)

        for i, v in z_opt.iteritems():
            print 'z = %f' % (v)
        print '\n'

    return [opt_val, x_opt, z_opt]


# obtain a sampling point from the interior of P
# check idea in cprnd.m
#def polyRandomPoint(P):
#    return x

# generate Gram-Schmidt orthogonalization process from columns of matrix A
def gram_schmidt_columns(A):
    import numpy as np

    Q, R = np.linalg.qr(A)
    return Q

# generate Gram-Schmidt orthogonalization process from rows of matrix A
def gram_schmidt_rows(A):
    import numpy as np

    Q, R = np.linalg.qr(A.T)
    return Q


def dHp(X, Xhat, p=_sage_const_2 , verbose = _sage_const_1 ):
    """ Compute approximation to Hausdorff distance using the rows of X, in the p-norm
    Use p=2 for Euclidean norm (default); p='inf' for sup-norm
    """
    [A, b] = polytopeToHrep(X)
    [C, d] = polytopeToHrep(Xhat)

    aux = _sage_const_0 ;
    for i in range(A.nrows()):
        fi = A.row(i)
        sf = supp_fun_Ab(fi,C,d,verbose) #the optimum value is the first component, the second component is a dictionary containing the solution
        cfraction = (sf[_sage_const_0 ]-b[i])/vecpnorm(fi,p)
        if (cfraction > aux):
            aux = cfraction;

    pX = _sage_const_1 
    return aux*pX


#Compute dHp(X,Xhat) using the formula above. Assume that n = n1+n2. Assume that pX = 1
def dHp_2blocks(X, S, S1, S2, n1, n, p=_sage_const_2 , verbose=_sage_const_1 ):

    [F, g] = polytopeToHrep(X)
    aux = _sage_const_0 ;
    for i in range(F.nrows()):
        fi = F.row(i)

        BM1 = block_matrix(n1,n,[identity_matrix(n1),zero_matrix(n1,n2)])
        fi1 = S1.T*BM1*((~S).T*fi)
        sf1 = supp_fun_Ab(fi1,F,g,verbose)

        BM2 = block_matrix(n2,n,[zero_matrix(n2,n1), identity_matrix(n2)])
        fi2 = S2.T*BM2*((~S).T*fi)
        sf2 = supp_fun_Ab(fi2,F,g,verbose)

        cfraction = (sf1[_sage_const_0 ] + sf2[_sage_const_0 ] - g[i])/vecpnorm(fi,p)
        if (cfraction > aux):
            aux = cfraction;

        return aux


#Compute dHp(X,Xhat) using the formula above. nL = [n1,...,nq], with n = sum(nL). Assume that pX0 = 1
#By default we use p=2 norm; use p='inf' for sup-norm
def dHp_qblocks(X, S, nL, p=_sage_const_2 , verbose=_sage_const_0 ):

    if 'list' in str(type(X)):
        F = X[_sage_const_0 ]; g = X[_sage_const_1 ]
    elif 'polyhedron' in str(type(X)):
        [F, g] = polytopeToHrep(X)


    if (verbose):
        print F # en el ejemplo, F tiene que ser de 12x6


    q = len(nL)
    n = sum(nL)

    aux = _sage_const_0 ;
    for i in range(F.nrows()):
        fi = F.row(i)

        #print 'fi = ', fi

        aux_sfSum = _sage_const_0 
        for j in range(q):

            ILj = list()

            for k in (ellipsis_range(_sage_const_0 ,Ellipsis,j-_sage_const_1 )):
                ILj.append(zero_matrix(nL[j],nL[k]))

            ILj.append(identity_matrix(nL[j]))

            for k in (ellipsis_range(j+_sage_const_1 ,Ellipsis,q-_sage_const_1 )):
                ILj.append(zero_matrix(nL[j],nL[k]))

            I_nj_n = block_matrix(RR, ILj, nrows=_sage_const_1 , ncols=q)
            #print 'Injn = ', I_nj_n

            #alternativo, mas corto, revisar:
            #I_nj_n = zero_matrix(RR, nL[j], n)
            #I_nj_n.set_block(0, nL[j], identity_matrix(nL[j]))


            Sj = S.submatrix(row = sum(nL[k] for k in (ellipsis_range(_sage_const_0 ,Ellipsis,j-_sage_const_1 ))), col=_sage_const_0 , nrows=nL[j])
            #print 'Sj = ', Sj

            #print 'before fij'
            #print len(fi), size(S)
            #type(I_nj_n)
            #type(S)
            #type(fi)

            fij = Sj.T*I_nj_n*((~S).T*fi)
            #print 'fij = ', fij

            #print 'after fij'
            sfj = supp_fun_Ab(fij, F, g, verbose)
            #print 'sfj = ', sfj

            aux_sfSum += sfj[_sage_const_0 ]


        cfraction = (aux_sfSum - g[i])/vecpnorm(fi,p)
        if (cfraction > aux):
            aux = cfraction;

    pX0 = _sage_const_1 

    return aux*pX0


# exploring automatically all partitions
# Warning: this search has exponential cost. By assumption we exclude q=1.
# By default we use p=2 norm; use p='inf' for sup-norm
def find_minimal_qBlocks(constraint_pairs_list, X, S, p=_sage_const_2 , verbose = _sage_const_0 ):

    if 'list' in str(type(X)):
        F = X[_sage_const_0 ]; g = X[_sage_const_1 ]
    elif 'polyhedron' in str(type(X)):
        [F, g] = polytopeToHrep(X)

    r = len(constraint_pairs_list)
    n = F.ncols()

    # generate sticks ...|..|...|..
    allowed_list = [_sage_const_1 +i for i in range(n-_sage_const_1 )]
    for i in range(r):
        allowed_list.remove(constraint_pairs_list[i][_sage_const_0 ])

    print 'allowed list (position of sticks) = ', allowed_list

    dHp_all = list()
    nL_all = list()

    # generate all combinations of q blocks
    for q in (ellipsis_range(_sage_const_2 ,Ellipsis,n-r)): #q-1 is the number of sticks

        if (verbose):
            print '\n', 'q ', q

        C = Combinations(allowed_list, q-_sage_const_1 )
        CList = C.list()

        for k in range(len(CList)): #k is an index for each possible combination
            nL_aux = list()
            nL_aux.append(CList[k][_sage_const_0 ])
            for j in (ellipsis_range(_sage_const_1 ,Ellipsis,q-_sage_const_2 )):
                nL_aux.append(CList[k][j]-CList[k][j-_sage_const_1 ])
            nL_aux.append(n - CList[k][q-_sage_const_2 ])

            dHp_aux = dHp_qblocks(X, S, nL_aux, p, verbose=_sage_const_0 )
            nL_all.append(nL_aux)
            dHp_all.append(dHp_aux)

            if (verbose):
                print 'k ', k, '  Comb = ', CList[k],  '  nL = ', nL_aux, '  dHp = ', dHp_aux.N(digits=_sage_const_6 )


    return dHp_all, nL_all



#Compute dHp(X,Xhat) using the formula above. nL = [n1,...,nq], with n = sum(nL). Assume that pX0 = 1
#By default we use p=2 norm; use p='inf' for sup-norm
def dHp_qblocks_optimized(F, g, S, nL, p=_sage_const_2 , verbose=_sage_const_0 ):

    q = len(nL)
    n = sum(nL)
    #print 'q=', q
    #print 'n=', n

    nL.insert(_sage_const_0 ,_sage_const_0 );
    indices_partitions = matrix(ZZ, np.tril(np.ones((q+_sage_const_1 ,q+_sage_const_1 )), _sage_const_0 ))*vector(ZZ, nL);

    # check that the size of S equals n
    # how to use Cython in these loops?
    # how to incorporate Gurobi solver in the supp_fun_Ab(..)?

    aux = _sage_const_0 ;

    # Prepare LP
    s_LP = MixedIntegerLinearProgram(maximization=True, solver = "GLPK")
    x = s_LP.new_variable(integer=False, nonnegative=False)

    # numpy arrays : use a different solver !
    #s_LP.add_constraint(matrix(F) * x <= vector(g)); # without the cast to matrix/vector, I get an unsupported operand error

    # sage dense matrices
    s_LP.add_constraint(F * x <= g);


    for i in range(F.nrows()):
        fi = F.row(i)

        aux_sfSum = _sage_const_0 

        #print 'i=', i

        for j in range(q):

            #ILj = list()
            #for k in [0..j-1]:
            #    ILj.append(zero_matrix(nL[j],nL[k]))
            #ILj.append(identity_matrix(nL[j]))
            #for k in [j+1..q-1]:
            #    ILj.append(zero_matrix(nL[j],nL[k]))
            #I_nj_n = block_matrix(RR, ILj, nrows=1, ncols=q)
            #print I_nj_n
            #Sj = S.submatrix(row = sum(nL[k] for k in [0..j-1]), col=0, nrows=nL[j])
            #fij = Sj.T*I_nj_n*((~S).T*fi)

            # if S is a sage dense matrix
            M = S[indices_partitions[j]:indices_partitions[j+_sage_const_1 ],:].T*S[indices_partitions[j]:indices_partitions[j+_sage_const_1 ],:];
            fij = M*fi;

            # Set objective function and solve LP
            # sfj = supp_fun_Ab(fij, F, g, verbose)
            obj = sum(fij[i]*x[i] for i in range(n))
            s_LP.set_objective(obj)

            sfj = s_LP.solve()

            aux_sfSum += sfj

            #print '    j= ', j, '    sfj = ', sfj[0]
            #print '     fij = ', fij

        # define next term
        #cfraction = (aux_sfSum - g[i])/vecpnorm(fi,p)
        # Recall that the coeff matrix satisfies vecpnorm(fi, p)=1 for most models.
        cfraction = (aux_sfSum - g[i])

        if (cfraction > aux):
            aux = cfraction;

    #pX0 = 1 # asphericity is 'assumed' = 1
    # aux = aux*px0
    return aux


#Compute dHp(X,Xhat) using the formula above. nL = [n1,...,nq], with n = sum(nL). Assume that pX0 = 1
#By default we use p=2 norm; use p='inf' for sup-norm
def dHp_qblocks_optimized_numpy(F, g, S, nL, p=_sage_const_2 , verbose=_sage_const_0 ):

    q = len(nL)
    n = sum(nL)
    #print 'q=', q
    #print 'n=', n

    nL.insert(_sage_const_0 ,_sage_const_0 );
    indices_partitions = matrix(ZZ, np.tril(np.ones((q+_sage_const_1 ,q+_sage_const_1 )), _sage_const_0 ))*vector(ZZ, nL);

    # check that the size of S equals n
    # how to use Cython in these loops?
    # how to incorporate Gurobi solver in the supp_fun_Ab(..)?

    aux = _sage_const_0 ;

    # Prepare LP
    s_LP = MixedIntegerLinearProgram(maximization=True, solver = "GLPK")
    x = s_LP.new_variable(integer=False, nonnegative=False)

    # numpy arrays : use a different solver !
    #s_LP.add_constraint(matrix(F) * x <= vector(g)); # without the cast to matrix/vector, I get an unsupported operand error

    # sage dense matrices
    s_LP.add_constraint(F * x <= g);


    for i in range(F.nrows()):
        fi = F.row(i)

        aux_sfSum = _sage_const_0 

        #print 'i=', i

        for j in range(q):

            #ILj = list()
            #for k in [0..j-1]:
            #    ILj.append(zero_matrix(nL[j],nL[k]))
            #ILj.append(identity_matrix(nL[j]))
            #for k in [j+1..q-1]:
            #    ILj.append(zero_matrix(nL[j],nL[k]))
            #I_nj_n = block_matrix(RR, ILj, nrows=1, ncols=q)
            #print I_nj_n
            #Sj = S.submatrix(row = sum(nL[k] for k in [0..j-1]), col=0, nrows=nL[j])
            #fij = Sj.T*I_nj_n*((~S).T*fi)

            # if S is a sage dense matrix
            M = S[indices_partitions[j]:indices_partitions[j+_sage_const_1 ],:].T*S[indices_partitions[j]:indices_partitions[j+_sage_const_1 ],:];
            fij = M*fi;

            # Set objective function and solve LP
            # sfj = supp_fun_Ab(fij, F, g, verbose)
            obj = sum(fij[i]*x[i] for i in range(n))
            s_LP.set_objective(obj)

            sfj = s_LP.solve()

            aux_sfSum += sfj

            #print '    j= ', j, '    sfj = ', sfj[0]
            #print '     fij = ', fij

        # define next term
        cfraction = (aux_sfSum - g[i])/vecpnorm(fi,p)
        # Recall that the coeff matrix satisfies vecpnorm(fi, p)=1 for most models.
        #cfraction = (aux_sfSum - g[i])

        if (cfraction > aux):
            aux = cfraction;

    #pX0 = 1 # asphericity is 'assumed' = 1
    # aux = aux*px0
    return aux
