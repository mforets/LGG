# This file was *autogenerated* from the file ./lib/polyFunctions_core.sage
from sage.all_cmdline import *   # import sage library
_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_5 = Integer(5)
r"""
Extension to polyhedra library for the purpose of mathematical modeling, with a focus on computational geometry.

Contains commonly used functions to define, transform, and compute with polytopes and with dense matrices. It extends SageMath Polyhedron class for constructing polyhedra, and if desired produces automatic cast into exact rings (such as RDF -> QQ). Moreover, it includes functions for usual tasks in computational geometry, such as support functions, application of linear maps, and generating random polytopes.

AUTHORS:

- Marcelo Forets (last modified 2016-10-20)

EXAMPLES::

See 'Examples-polyFunctions-core.ipynb'
"""

#*****************************************************************************
#       Copyright (C) 2016 Marcelo Forets <mforets@nonlinearnotes.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************

def PolyhedronFromHSpaceRep(A, b, base_ring=QQ):
    r"""Builds a polytope given the H-representation, in the form Ax <= b
    
    INPUT: 
       
    * "A" - generic (Sage) dense matrix of size m x n, in RR or QQ ring
       
    * "b" - generic (Sage) dense vector of size m, in RR or QQ ring 
       
    * "base_ring" - (default: QQ). Specifies the ring (base_ring) for the Polyhedron constructor. Valid choices are:
        
        * QQ - rational. Uses 'ppl' (Parma Polyhedra Library) backend 
        
        * RDF - Real double field. Uses 'cdd' backend.
       
    OUTPUT: 
       
    * "P" - a Polyhedron object
       
    EXAMPLES: 
       
    sage: A = matrix(RDF, [[-1.0, 0.0,  0.0,  0.0,  0.0,  0.0],
[ 1.0,  0.0,  0.0,  0.0,  0.0,  0.0],
[ 0.0,  1.0,  0.0,  0.0,  0.0,  0.0],
[ 0.0, -1.0,  0.0,  0.0,  0.0,  0.0],
[ 0.0,  0.0, -1.0,  0.0,  0.0,  0.0],
[ 0.0,  0.0,  1.0,  0.0,  0.0,  0.0],
[ 0.0,  0.0,  0.0, -1.0,  0.0,  0.0],
[ 0.0,  0.0,  0.0,  1.0,  0.0,  0.0],
[ 0.0,  0.0,  0.0,  0.0,  1.0,  0.0],
[ 0.0,  0.0,  0.0,  0.0, -1.0,  0.0],
[ 0.0,  0.0,  0.0,  0.0,  0.0,  1.0],
[ 0.0,  0.0,  0.0,  0.0,  0.0, -1.0]])

    sage: b = vector(RDF, [0.0, 10.0, 0.0, 0.0, 0.2, 0.2, 0.1, 0.1, 0.0, 0.0, 0.0, 0.0])

    sage: P = PolyhedronFromHSpaceRep(A, b, base_ring=QQ); P
        
    A 3-dimensional polyhedron in QQ^6 defined as the convex hull of 8 vertices (use the .plot() method to plot)

    NOTE: 
    
    This function is useful especially when the input matrices A, b are ill-defined (constraints that differ by tiny amounts making the input data to be degenerate or almost degenerate), causing problems to Polyhedron(...). In this case it is recommended to use base_ring = QQ. Each element of A and b will be converted to rational, and this will be sent to Polyhedron. Note that Polyhedron automatically removes redundant constraints. 
    
    """
    ieqs_list = list();
    ambient_dim = A.ncols()
    
    if (base_ring == RDF):
        for i in range(A.nrows()):
            ieqs_list.append(list(-A.row(i)))  #change in sign, necessary since Polyhedron receives Ax+b>=0
            ieqs_list[i].insert(_sage_const_0 ,b[i])
        
        P = Polyhedron(ieqs = ieqs_list, base_ring=RDF, ambient_dim=A.ncols(), backend='cdd')
        
    elif (base_ring == QQ):
        for i in range(A.nrows()):
            
            # transform to rational
            A.set_row(i,[QQ(A.row(i)[j]) for j in range(ambient_dim)]);
            
            ieqs_list.append(list(-A.row(i)))  #change in sign, necessary since Polyhedron receives Ax+b>=0
            ieqs_list[i].insert(_sage_const_0 ,QQ(b[i]))
            
        P = Polyhedron(ieqs = ieqs_list, base_ring=QQ, ambient_dim=A.ncols(), backend = 'ppl')

    return P

def PolyhedronToHSpaceRep(P, separate_equality_constraints = False):
    r"""Extract half-space representation of an input polytope P. By default, returns matrices [A, b] representing P as Ax <= b. If separate_equality_constraints = True, returns matrices [A, b, Aeq, beq], with separated inequality and equality constraints.
       
    INPUT: 
       
    * "P" - object of class polyhedron
       
    * "separate_equality_constraints" - (default = False) If True, returns Aeq, beq containing the equality constraints, and removes the corresponding lines from A and b.
       
    OUTPUT: 
       
    * "[A, b]" - dense matrix and vector respectively (dense, RDF).
       
    * "[A, b, Aeq, beq]" - (if the flag separate_equality_constraints is True), matrices and vectors (dense, RDF). Equality constraints are removed from A and put into Aeq.
       
    EXAMPLES: 
       
    sage: A = matrix(RDF, [[-1.0, 0.0,  0.0,  0.0,  0.0,  0.0],
[ 1.0,  0.0,  0.0,  0.0,  0.0,  0.0],
[ 0.0,  1.0,  0.0,  0.0,  0.0,  0.0],
[ 0.0, -1.0,  0.0,  0.0,  0.0,  0.0],
[ 0.0,  0.0, -1.0,  0.0,  0.0,  0.0],
[ 0.0,  0.0,  1.0,  0.0,  0.0,  0.0],
[ 0.0,  0.0,  0.0, -1.0,  0.0,  0.0],
[ 0.0,  0.0,  0.0,  1.0,  0.0,  0.0],
[ 0.0,  0.0,  0.0,  0.0,  1.0,  0.0],
[ 0.0,  0.0,  0.0,  0.0, -1.0,  0.0],
[ 0.0,  0.0,  0.0,  0.0,  0.0,  1.0],
[ 0.0,  0.0,  0.0,  0.0,  0.0, -1.0]])

    sage: b = vector(RDF, [0.0, 10.0, 0.0, 0.0, 0.2, 0.2, 0.1, 0.1, 0.0, 0.0, 0.0, 0.0])

    sage: P = PolyhedronFromHSpaceRep(A, b, base_ring = RDF); P
        
    A 3-dimensional polyhedron in RDF^6 defined as the convex hull of 8 vertices (use the .plot() method to plot)

    sage: [A, b] = PolyhedronToHSpaceRep(P); A, b
        
        (
[-0.0  1.0 -0.0 -0.0 -0.0 -0.0]
[ 0.0 -1.0  0.0  0.0  0.0  0.0]
[-0.0 -0.0 -0.0 -0.0  1.0 -0.0]
[ 0.0  0.0  0.0  0.0 -1.0  0.0]
[-0.0 -0.0 -0.0 -0.0 -0.0  1.0]
[ 0.0  0.0  0.0  0.0  0.0 -1.0]
[-1.0 -0.0 -0.0 -0.0 -0.0 -0.0]
[ 1.0 -0.0 -0.0 -0.0 -0.0 -0.0]
[-0.0 -0.0 -1.0 -0.0 -0.0 -0.0]
[-0.0 -0.0  1.0 -0.0 -0.0 -0.0]
[-0.0 -0.0 -0.0 -1.0 -0.0 -0.0]
[-0.0 -0.0 -0.0  1.0 -0.0 -0.0],

(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 10.0, 0.2, 0.2, 0.1, 0.1)
)
        
    NOTE: 
    
    This function is used to revert the job of polytopeFromHalfSpaceRep(A, b, base_ring = RDF). However, it is not the inverse generally, because of: (i) automatic reordering of rows (this is uncontrolled, internal to Polyhedron), and (ii) scaling. In the example of above, with a polyhedron in RDF we see reordering of rows. If we choose QQ, then we have both reordering and rescaling:
        
    sage: P = PolyhedronFromHSpaceRep(A, b, base_ring = QQ); P
        
    A 3-dimensional polyhedron in QQ^6 defined as the convex hull of 8 vertices (use the .plot() method to plot)
        
    sage: [A, b] = PolyhedronToHSpaceRep(P); A, b
        
        (
[  0.0   0.0   0.0   0.0   0.0  -1.0]
[  0.0   0.0   0.0   0.0   0.0   1.0]
[  0.0   0.0   0.0   0.0  -1.0   0.0]
[  0.0   0.0   0.0   0.0   1.0   0.0]
[  0.0  -1.0   0.0   0.0   0.0   0.0]
[  0.0   1.0   0.0   0.0   0.0   0.0]
[ -1.0   0.0   0.0   0.0   0.0   0.0]
[  0.0   0.0   5.0   0.0   0.0   0.0]
[  0.0   0.0  -5.0   0.0   0.0   0.0]
[  0.0   0.0   0.0 -10.0   0.0   0.0]
[  0.0   0.0   0.0  10.0   0.0   0.0]
[  1.0   0.0   0.0   0.0   0.0   0.0],

(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 10.0)
)

    The polytope P is not full-dimensional; to extract the equality constraints we use the flag separate_equality_constraints: 
        
    sage: [A, b, Aeq, beq] = PolyhedronToHSpaceRep(P, separate_equality_constraints = True)
        
    sage: A, b
        
        (
[ -1.0   0.0   0.0   0.0   0.0   0.0]                                 
[  0.0   0.0   5.0   0.0   0.0   0.0]                                 
[  0.0   0.0  -5.0   0.0   0.0   0.0]                                 
[  0.0   0.0   0.0 -10.0   0.0   0.0]                                 
[  0.0   0.0   0.0  10.0   0.0   0.0]                                 
[  1.0   0.0   0.0   0.0   0.0   0.0], (0.0, 1.0, 1.0, 1.0, 1.0, 10.0)
)
        
    sage: Aeq, beq
        
        (
[ 0.0  0.0  0.0  0.0  0.0 -1.0]               
[ 0.0  0.0  0.0  0.0 -1.0  0.0]               
[ 0.0 -1.0  0.0  0.0  0.0  0.0], [0.0 0.0 0.0]
)

"""

    if not separate_equality_constraints:
        # a priori I don't know number of equalities; actually m may be bigger than len(P.Hrepresentation()) !
        # for this, we should transform equalities into inequalities, so that Ax <= b is correct.
        b = list(); A = list()
    
        P_gen = P.Hrep_generator();
    
        for pigen in P_gen:
            if (pigen.is_equation()):
                pi_vec = pigen.vector()
                A.append(-pi_vec[_sage_const_1 :len(pi_vec)])
                b.append(pi_vec[_sage_const_0 ])

                A.append(pi_vec[_sage_const_1 :len(pi_vec)])
                b.append(pi_vec[_sage_const_0 ])
            
            else:
                pi_vec = pigen.vector()
                A.append(-pi_vec[_sage_const_1 :len(pi_vec)])
                b.append(pi_vec[_sage_const_0 ])
            
        return [matrix(RDF, A), vector(RDF, b)]
    
    else: 
        b = list(); A = list(); beq = list(); Aeq = list()
        
        P_gen = P.Hrep_generator();
        
        for pigen in P_gen:
            if (pigen.is_equation()):
                pi_vec = pigen.vector()
                Aeq.append(-pi_vec[_sage_const_1 :len(pi_vec)])
                beq.append(pi_vec[_sage_const_0 ])
            
            else:
                pi_vec = pigen.vector()
                A.append(-pi_vec[_sage_const_1 :len(pi_vec)])
                b.append(pi_vec[_sage_const_0 ])
            
    return [matrix(RDF, A), vector(RDF, b), matrix(RDF, Aeq), matrix(RDF, beq)]
           

def BallInfty(center, radius, base_ring=QQ):
    r"""Generate a ball (polytope) in the supremum norm of given center and radius.
       
    INPUT: 
       
    * "center" - a vector (or a list) containing the coordinates of the center of the ball.
       
    * "radius" - a number representing the radius of the ball. 
       
    * "base_ring" - (default: QQ) base ring passed to the Polyhedron constructor. Valid choices are:
        
        * "'QQ'": rational
        
        * "'RDF'": real double field
    
    OUTPUT: 
       
    * "P" - a Polyhedron object
       
    EXAMPLES: 
       
    sage: P = BallInfty([1,2,3], 1); P
        
    A 3-dimensional polyhedron in QQ^3 defined as the convex hull of 8 vertices (use the .plot() method to plot)
    
    sage: P.plot(aspect_ratio=1)
    
    <to plot the 3D box>
    
    TO-DO: 
    
    Add possibility to output in matrix form [A, b]. This is especially intersting for more than 15 variable systems.
    
    """
    
    #if (type(center) == list):
    #    ndim = len(center)
    #elif (type(center) == sage.modules.vector_real_double_dense.Vector_real_double_dense):
    #    ndim = center.length()
    
    ndim = len(center)    
    A = matrix(base_ring, _sage_const_2 *ndim, ndim); b = vector(base_ring,_sage_const_2 *ndim)

    count = _sage_const_0 
    for i in range(ndim):
        diri = zero_vector(base_ring,ndim)
        diri[i] = _sage_const_1 

        # external bound
        A.set_row(count, diri)
        b[count] = center[i] + radius
        count += _sage_const_1 
        
        # internal bound
        A.set_row(count, -diri)
        b[count] = -(center[i] - radius)
        count += _sage_const_1 
    
    P = PolyhedronFromHSpaceRep(A, b, base_ring)
    
    return P



# receive a matrix B and a polyhedron U and output the polyhedron V = BU
def matTimesPol(B, U):
    vertices_U = U.vertices_list()
    vertices_V = [np.dot(B, vertices_U[i]) for i in range(len(vertices_U))]
    V = Polyhedron(vertices = vertices_V, base_ring=RDF)
    return V


# generate an n-dimensional box
# lengths is a list of pairs, containing the max and min of each coordinate
# Example: polyBox([(1.1,0.9),(0.1,-0.1)])
def polyBox(lengths):
    ndim = len(lengths)

    A = matrix(RR, _sage_const_2 *ndim, ndim)
    b = vector(RR,_sage_const_2 *ndim)

    count = _sage_const_0 
    for i in range(ndim):
        diri = zero_vector(RR,ndim)
        diri[i] = _sage_const_1 

        # external bound
        A.set_row(count, diri)
        b[count] = lengths[i][_sage_const_0 ]
        count += _sage_const_1 
        
        # internal bound
        A.set_row(count, -diri)
        b[count] = -(lengths[i][_sage_const_1 ])
        count += _sage_const_1 
    
    
    P = polytopeFromHrep(A, b)
    
    return P

# generate a random polygon (2d) obtained sampling the unit circle
def polygonRandom2d(num_vertices):
    import random
    import numpy as np

    # generate random X
    anglesX = [random.uniform(_sage_const_0 , _sage_const_2 *pi.n(digits=_sage_const_5 )) for i in range(num_vertices)]
    vertX = [[exp(I*anglesX[i]).real(), exp(I*anglesX[i]).imag()] for i in range(num_vertices)]
    X = Polyhedron(vertices = vertX, base_ring=RDF)
    
    return X


# generate -P, defined as the polytope such that x in -P iff -x in P
def oppositePolytope(P):
    Pinv = Polyhedron(vertices = [-_sage_const_1 *vector(i) for i in P.vertices_list()], base_ring = RDF)
    return Pinv


# compute an n-dimensional box of given center and radius
def polyBox_cr(center, radius):
    
    ndim = len(center)
    A = matrix(RR, _sage_const_2 *ndim, ndim)
    b = vector(RR,_sage_const_2 *ndim)

    count = _sage_const_0 
    for i in range(ndim):
        diri = zero_vector(RR,ndim)
        diri[i] = _sage_const_1 

        # external bound
        A.set_row(count, diri)
        b[count] = center[i]+radius  # lengths[i][0]
        count += _sage_const_1 
        
        # internal bound
        A.set_row(count, -diri)
        b[count] = -(center[i]-radius)
        count += _sage_const_1 
    
    
    P = polytopeFromHrep(A, b)
    
    return P


def poly_sup_norm(P):
    r"""Compute maximum norm of any element in a polyhedron (in the sup norm). 
    
    It is defined as max_{x in P} ||x||_inf. It can be computed with support functions as max_{i=1,...,n} max{|rho(P, ei)|, |rho(P,-ei)|}, where rho(P, ei) is the support function of P evaluated at ei, and ei is the i-th canonical vector in R^n. 
       
    INPUT: 
       
    * "P" - an object of class Polyhedron. It can also be given as [A, b] with A and b matrices, assuming Ax <= b.
       
    OUTPUT: 
       
    * "snorm" - the value of the max norm of any element of P, in the sup-norm.
    
    """   
    
    if (type(P) == list):
        
        A = P[_sage_const_0 ]; b = P[_sage_const_1 ];
        # obtain dimension of the ambient space 
        n = A.ncols();
        
        r = _sage_const_0 
        for i in range(n):
            # generate canonical direction
            d = zero_vector(RR,n)
            d[i] = _sage_const_1         
            aux_sf = abs(supp_fun_polyhedron([A, b], d))
            if (aux_sf >= r):
                r = aux_sf;
            
            # change sign
            d[i] = -_sage_const_1 
            aux_sf = abs(supp_fun_polyhedron([A, b], d))
            if (aux_sf >= r):
                r = aux_sf;
        snorm = r
        return snorm
        
    else: # Assuming P is some form of polyhedron
       
        # returns the bounds from below and from above for the coordinates of a rectangular box containing the polytope
        vertices = P.bounding_box() 
        snorm = max(max([abs(vertices_coord) for vertices_coord in v]) for v in vertices)
        return snorm


def supp_fun_polyhedron(P, d, verbose = _sage_const_0 , return_xopt = False, solver = 'GLPK'): 
    r"""Compute support function of a convex polytope.
    
    It is defined as max_{x in P} <x,d> , where d is an input vector.
       
    INPUT: 
       
    * "P" - an object of class Polyhedron. It can also be given as [A, b] with A and b matrices, assuming Ax <= b.
       
    * "d" - a vector (or list) where the support function is evaluated. 
       
    * "verbose" - (default: 0) If 1, print the status of the LP.
    
    * "solver" - (default: 'GLPK') the LP solver used. 
    
    * "return_xopt" - (default: False) If True, the optimal point is returned, and sf = [oval, opt].
    
    OUTPUT: 
       
    * "sf" - the value of the support function. 
       
    EXAMPLES: 
       
    sage: P = BallInfty([1,2,3], 1); P
        
    A 3-dimensional polyhedron in QQ^3 defined as the convex hull of 8 vertices (use the .plot() method to plot)
    
    sage: supp_fun_polyhedron(P, [1,1,1], return_xopt=True)
    
    **** Solve LP (using GLPK) ****
Maximization:
  x_0 + x_1 + x_2
Constraints:
  x_0 <= 2.0
  x_1 <= 3.0
  x_2 <= 4.0
  - x_0 <= 0.0
  - x_2 <= -2.0
  - x_1 <= -1.0
Variables:
  x_0 is a continuous variable (min=-oo, max=+oo)
  x_1 is a continuous variable (min=-oo, max=+oo)
  x_2 is a continuous variable (min=-oo, max=+oo)
Objective Value: 9.0
x_0 = 2.000000
x_1 = 3.000000
x_2 = 4.000000


(9.0, {0: 2.0, 1: 3.0, 2: 4.0})
    
    NOTES:
    
    The possibility of giving the input polytope as [A, b] instead of a polyhedron P is useful in cases when the dimensions are high (in practice, more than 30, but it depends on the particular system -number of constraints- as well). In fact, it is often the case that the data is given in matrix format (A, b), hence it might be preferable to avoid the overhead of building the Polyhedra, if our intention is solely to make computations that can be performed on the matrices A and b directly. Moreover, the improve in speed is quite considerable.
    
    If a different solver is given, it should be installed properly. 
    
    sage: supp_fun_polyhedron(P, [1,1,1], solver='Gurobi')
    
    ImportError: No module named gurobi_backend
    
    """
    s_LP = MixedIntegerLinearProgram(maximization=True, solver = solver)
    x = s_LP.new_variable(integer=False, nonnegative=False)

    # objective function
    obj = sum(d[i]*x[i] for i in range(len(d)))
    s_LP.set_objective(obj)
    
    if (type(P) == list):
        A = P[_sage_const_0 ]; b = P[_sage_const_1 ];
        
    else: #assuming some form of Polyhedra 
        
        # extract the constraints from P
        m = len(P.Hrepresentation())
        n = len(vector( P.Hrepresentation()[_sage_const_0 ] ))-_sage_const_1 
        b = vector(RR, m)
        A = matrix(RR, m, n)
        P_gen = P.Hrep_generator();
        i=_sage_const_0 
        for pigen in P_gen:
            pi_vec = pigen.vector()
            A.set_row(i, -pi_vec[_sage_const_1 :len(pi_vec)])
            b[i] = pi_vec[_sage_const_0 ]
            i+=_sage_const_1 ;
        
    s_LP.add_constraint(A * x <= b);    
        
    if (verbose):
        print '**** Solve LP (using GLPK) ****'    
        s_LP.show()
    
    oval = s_LP.solve()
    xopt = s_LP.get_values(x);
    
    if (verbose):
        print 'Objective Value:', oval
        for i, v in xopt.iteritems():
            print 'x_%s = %f' % (i, v)
        print '\n'
        
    if (return_xopt == True):
        return oval, xopt
    else:
        return oval

def supp_fun_ellipsoid(Q, d): 
    r"""Compute support function at d of a given ellipsoid.
    
    It is defined as max_{x in Q} <x,d>, where d is an input vector. The ellipsoid is defined as x.T*Q*x <= 1
       
    INPUT: 
       
    * "Q" - a square matrix.
       
    * "d" - a vector (or list) where the support function is evaluated. 
       
    OUTPUT: 
       
    * "sf" - the value of the support function.
    
    """    
    
    if (Q.is_singular()):
        print 'error: input matrix is not invertible'
        return
    else:
        if (type(d) == list):
            d = vector(d)
        return sqrt(d.inner_product((~Q)*d))
